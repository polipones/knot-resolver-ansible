-- Ansible managed
-- Refer to manual: https://knot-resolver.readthedocs.io/en/stable/

-- Network interface configuration
{% for addr in dns_listen_addresses %}
net.listen("{{ addr }}", {{ dns_listen_port_unencrypted }}, { kind = 'dns' })
{% if dns_tls_enable %}
net.listen("{{ addr }}", {{ dns_listen_port_tls }}, { kind = 'tls' })
{% endif %}
{% endfor %}

-- TLS server configuration
{% if dns_tls_enable %}
net.tls("{{ dns_tls_cert_key_directory }}/fullchain.pem", "{{ dns_tls_cert_key_directory }}/privkey.pem")
{% endif %}
-- Refer to manual for optimal cache size
cache.size = {{ dns_cache_size }} * MB

{% if dns_cache_in_memory %}
cache.storage = 'lmdb:///var/cache/knot-resolver'
{% endif %}

-- load modules
modules = {
    'view',
    'stats',
    'predict'
}

{% if dns_statistics_log_enable %}
-- log statistics
event.recurrent({{ dns_statistics_log_interval }} * minute, function(evid)
    log(table_print(stats.list()))
end)

{% endif %}

-- speed_monitor definition
-- prints warning if more than 5% of total answers was slow
function speed_monitor()
        local previous = stats.list()   -- store statistics in persistent variable
        return function(evid)
                local now = stats.list()    -- save actual statistics to variable
                -- number of total answers between 'now' and 'previous' states
                local total_increment = now['answer.total'] - previous['answer.total']
                -- number of slow answers between 'now' and 'previous' states
                local slow_increment = now['answer.slow'] - previous['answer.slow']
                -- if percentage of slow answers is bigger than 5%, print warning
                if slow_increment / total_increment > 0.05 then
                        log('WARNING! More than 5 %% of queries was slow!')
                end
                previous = now
         end
end

-- execute speed_monitor every minute
local monitor_id = event.recurrent(1 * minute, speed_monitor())

{% if dns_only_allowed_subnets %}
-- whitelist queries identified by subnet
{% for sub in dns_allowed_subnets %}
view:addr("{{ sub }}", policy.all(policy.PASS))
{% endfor %}

-- drop everything that hasn't matched
view:addr('0.0.0.0/0', policy.all(policy.DROP))
{% endif %}